// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc613.SwerveDrive4.subsystems;

import org.usfirst.frc613.SwerveDrive4.RobotMap;
import org.usfirst.frc613.SwerveDrive4.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class DriveTrain extends Subsystem {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	SpeedController left = RobotMap.driveTrainLeft;
	SpeedController right = RobotMap.driveTrainRight;
	RobotDrive drive = RobotMap.driveTrainDrive;
	SpeedController leftSpin = RobotMap.driveTrainLeftSpin;
	SpeedController fakeWheel = RobotMap.driveTrainFakeWheel;
	RobotDrive swerve = RobotMap.driveTrainSwerve;
	SpeedController rrightSpin = RobotMap.driveTrainRrightSpin;
	Encoder leftEncoder = RobotMap.driveTrainLeftEncoder;
	Encoder rightEncoder = RobotMap.driveTrainRightEncoder;

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	// Put methods for controlling this subsystem
	// here. Call these from Commands.

	public void initDefaultCommand() {
		// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
		setDefaultCommand(new DrivewithJoysticks());

		// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

		// Set the default command for a subsystem here.
		// setDefaultCommand(new MySpecialCommand());
	}

	public void driveWithJoysticks(Joystick stick) {
		drive.tankDrive(stick, stick);
		swerve.tankDrive(stick.getX(), stick.getX());
		double turn = stick.getDirectionDegrees();
		turn = turn * 5.556;
		int turnEncoder = (int) turn;
		SmartDashboard.putNumber("Turn to:", turnEncoder);
		int nLeftEncoder = leftEncoder.getRaw() % 2000;
		int nRightEncoder = rightEncoder.getRaw() % 2000;
		SmartDashboard.putNumber("Neo Left Encoder Value", nLeftEncoder);
		SmartDashboard.putNumber("Neo Right Encooder Value", nRightEncoder);

		if (Math.abs(nLeftEncoder - turnEncoder) < 50) {
			leftSpin.set(0);
		} else if (nLeftEncoder > turnEncoder) {
			leftSpin.set((nLeftEncoder - turnEncoder) / 500);
		} else if (nLeftEncoder < turnEncoder) {
			leftSpin.set((turnEncoder - nLeftEncoder) / 500);
		}

		if (nRightEncoder - turnEncoder < 50
				&& nRightEncoder - turnEncoder > -50) {
			rrightSpin.set(0);
		} else if (nRightEncoder > turnEncoder) {
			rrightSpin.set((nRightEncoder - turnEncoder) / 500);
		} else if (nRightEncoder < turnEncoder) {
			rrightSpin.set((turnEncoder - nRightEncoder) / 500);
		}

		/*
		 * if((leftEncoder.getRaw())-(rightEncoder.getRaw())<=25||(rightEncoder.
		 * getRaw())-(leftEncoder.getRaw())>=25) { rrightSpin.set(0); } else
		 * if((leftEncoder.getRaw())<(rightEncoder.getRaw())) {
		 * rrightSpin.set(stick
		 * .getX()*((rightEncoder.getRaw())-(leftEncoder.getRaw()))/500+.5); }
		 * else if((rightEncoder.getRaw())<(leftEncoder.getRaw())) {
		 * rrightSpin.set
		 * (stick.getX()*((leftEncoder.getRaw())-(rightEncoder.getRaw
		 * ()))/500-.5); }
		 */
	}

	public void TurnLeft() {
		/*
		 * if ((leftEncoder.getRaw())>550||(leftEncoder.getRaw())<450) { if
		 * ((leftEncoder.getRaw())<500) { leftSpin.set(.5); } else if
		 * ((leftEncoder.getRaw())>500) { leftSpin.set(-.5); } }
		 */
	}

	public void TurnRight() {
		/*
		 * if ((leftEncoder.getRaw())<-550||(leftEncoder.getRaw())>-450) { if
		 * ((leftEncoder.getRaw())>-500) { leftSpin.set(-.5); } else if
		 * ((leftEncoder.getRaw())<-500) { leftSpin.set(.5); } }
		 */
	}
	// if
}
